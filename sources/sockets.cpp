// Generated by GPT
#include "sockets.h"

Socket::Socket() : m_socket(-1) {}

Socket::~Socket() {
    Close();
}

bool Socket::Create() {
    m_socket = socket(AF_INET, SOCK_STREAM, 0);
    return m_socket != -1;
}

bool Socket::Bind(const std::string& address, int port) {
    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port);
    if (inet_pton(AF_INET, address.c_str(), &serverAddr.sin_addr) <= 0) {
        return false;
    }
    return bind(m_socket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) != -1;
}

bool Socket::Listen(int backlog) {
    return listen(m_socket, backlog) != -1;
}

bool Socket::Accept(Socket& newSocket) {
    struct sockaddr_in clientAddr;
    socklen_t clientAddrLen = sizeof(clientAddr);
    int newSocketDescriptor = accept(m_socket, (struct sockaddr*)&clientAddr, &clientAddrLen);
    if (newSocketDescriptor == -1) {
        return false;
    }
    newSocket.m_socket = newSocketDescriptor;
    return true;
}

bool Socket::Connect(const std::string& address, int port) {
    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port);
    if (inet_pton(AF_INET, address.c_str(), &serverAddr.sin_addr) <= 0) {
        return false;
    }
    return connect(m_socket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) != -1;
}

bool Socket::Send(const std::string& data) {
    ssize_t bytesSent = send(m_socket, data.c_str(), data.length(), 0);
    return bytesSent != -1;
}

bool Socket::Receive(std::string& data) {
    char buffer[1024];
    ssize_t bytesRead = recv(m_socket, buffer, sizeof(buffer), 0);
    if (bytesRead <= 0) {
        return false;
    }
    data.assign(buffer, bytesRead);
    return true;
}

void Socket::Close() {
    if (m_socket != -1) {
        close(m_socket);
        m_socket = -1;
    }
}

// 移动构造函数
Socket::Socket(Socket&& other) : m_socket(other.m_socket) {
    other.m_socket = -1;
}

// 移动赋值运算符
Socket& Socket::operator=(Socket&& other) {
    if (this != &other) {
        Close();
        m_socket = other.m_socket;
        other.m_socket = -1;
    }
    return *this;
}
